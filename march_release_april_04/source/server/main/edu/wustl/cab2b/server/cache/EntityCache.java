/**
 * <p>Title: EntityCache class>
 * <p>Description:	This class is used to cache the Entity and its Attribute objects.</p>
 * Copyright:    Copyright (c) year
 * Company: Washington University, School of Medicine, St. Louis.
 * @author Gautam Shetty
 * @version 1.00
 */
package edu.wustl.cab2b.server.cache;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import edu.common.dynamicextensions.domain.PermissibleValue;
import edu.common.dynamicextensions.domaininterface.AbstractAttributeInterface;
import edu.common.dynamicextensions.domaininterface.AssociationInterface;
import edu.common.dynamicextensions.domaininterface.AttributeInterface;
import edu.common.dynamicextensions.domaininterface.EntityGroupInterface;
import edu.common.dynamicextensions.domaininterface.EntityInterface;
import edu.common.dynamicextensions.domaininterface.PermissibleValueInterface;
import edu.common.dynamicextensions.domaininterface.SemanticPropertyInterface;
import edu.common.dynamicextensions.entitymanager.EntityManager;
import edu.common.dynamicextensions.entitymanager.EntityManagerInterface;
import edu.common.dynamicextensions.exception.DynamicExtensionsApplicationException;
import edu.common.dynamicextensions.exception.DynamicExtensionsSystemException;
import edu.wustl.cab2b.common.beans.Attribute;
import edu.wustl.cab2b.common.beans.Entity;
import edu.wustl.cab2b.common.beans.IAttribute;
import edu.wustl.cab2b.common.beans.IEntity;
import edu.wustl.cab2b.common.beans.MatchedClass;
import edu.wustl.cab2b.common.beans.MyHashMap;
import edu.wustl.cab2b.common.beans.SemanticProperty;
import edu.wustl.cab2b.common.beans.StringPermissibleValue;
import edu.wustl.cab2b.common.entityCache.IEntityCache;
import edu.wustl.cab2b.common.exception.RuntimeException;
import edu.wustl.cab2b.common.util.Constants;
import edu.wustl.cab2b.common.util.Utility;
import edu.wustl.cab2b.server.category.CategoryOperations;
import edu.wustl.common.querysuite.metadata.category.Category;
import edu.wustl.cab2b.server.util.InheritanceUtil;


/**
 * This class is used to cache the Entity and its Attribute objects.
 * @author gautam_shetty
 */
public class EntityCache implements IEntityCache, Serializable  {

    private static final long serialVersionUID = 1234567890L;

    /**
     * List of all Entity objects.
     */
    protected List<IEntity> entityList = new ArrayList<IEntity>();

    protected Map<Long,EntityInterface> idVsEntity = new HashMap<Long, EntityInterface>();
    protected Map<Long,IEntity> idVsIEntity = new HashMap<Long, IEntity>();
    protected Map<Long,IAttribute> idVsIAttribute = new HashMap<Long, IAttribute>();
    //TODO both of above maps might not be needed.Need to look at it, Only one of them should be sufficient
    protected Map<Long,AssociationInterface> idVsAssociation = new HashMap<Long, AssociationInterface>();
    /** This map holds all the original association. Associations which are replicated by cab2b are not present in this map
     * Key : String to identify a parent association uniquely.Generated by {@link InheritanceUtil#generateUniqueId(AssociationInterface)}
     * Value : Original association for given string identifier 
     * */
    protected Map<String,AssociationInterface>originalAssociations = new HashMap<String, AssociationInterface>();
    protected MyHashMap attributeEntityMap = new MyHashMap();
    protected MyHashMap permissibleValueToEntityMap = new MyHashMap();

    /**
     * The EntityCache object.
     */
    protected static EntityCache entityCache = null;
    protected static List<Category> categories;

    /**
     * Private default constructor.
     * Just to restrict the user from instantiating explicitly.  
     */
    private EntityCache() {
        refreshCache();
    }

    /**
     * Returns the singleton instance of the EntityCache class.
     * @return the singleton instance of the EntityCache class.
     */
    public static synchronized EntityCache getInstance() {
        if (entityCache == null) {
            entityCache = new EntityCache();
        }

        return entityCache;
    }

    /**
     * Initializes the entity cache.
     */
    private void init() throws RuntimeException {
        try {

            EntityManagerInterface entityManager = EntityManager.getInstance();
            Collection<EntityGroupInterface> entityGroups = entityManager.getAllEntitiyGroups();
            createCache(entityGroups);
            CategoryOperations catOp=new CategoryOperations();
            categories= catOp.getAllCategories();

        } catch (DynamicExtensionsSystemException dynSysExp) {
            throw new RuntimeException(dynSysExp.getMessage(), dynSysExp);
        } catch (DynamicExtensionsApplicationException dynAppExp) {
            throw new RuntimeException(dynAppExp.getMessage(), dynAppExp);
        }
    }

    private void createCache(Collection<EntityGroupInterface> entityGroups) {
        for(EntityGroupInterface entityGroup : entityGroups) {
            if(entityGroup.getName().equals(Constants.DATALIST_ENTITY_GROUP_NAME)) {
                continue; //Ignoring entity group of datalist for caching
            }
            for( EntityInterface entity: entityGroup.getEntityCollection()){
                idVsEntity.put(entity.getId(), entity);
                for(AssociationInterface association : entity.getAssociationCollection()) {
                    idVsAssociation.put(association.getId(), association);
                    if(!InheritanceUtil.isInherited(association)) {
                        originalAssociations.put(InheritanceUtil.generateUniqueId(association), association);    
                    }
                }
                Entity cab2bEntity = new Entity();
    
                cab2bEntity.setId(entity.getId());
                cab2bEntity.setName(entity.getName());
                cab2bEntity.setDescription(entity.getDescription());
                cab2bEntity.setCreatedDate(entity.getCreatedDate());
                cab2bEntity.setLastUpdated(entity.getLastUpdated());
                cab2bEntity.setTaggedValueCollection(entity.getTaggedValueCollection());
                cab2bEntity.setTableProperties(entity.getTableProperties());
                cab2bEntity.setAbstractAttributeCollection(createAttributeCache(entity));
                cab2bEntity.setEntityGroupCollection(entity.getEntityGroupCollection());
                cab2bEntity.setSemanticPropertyCollection(getSemanticProperty(entity.getSemanticPropertyCollection()));
                idVsIEntity.put(cab2bEntity.getId(),cab2bEntity);
              
                entityList.add(cab2bEntity);
            }
        }
    }
    
    private Collection<AbstractAttributeInterface> createAttributeCache(EntityInterface entity) {
        Collection<AbstractAttributeInterface> abstractAttributeCollection = new HashSet<AbstractAttributeInterface>();

        if (entity.getAbstractAttributeCollection() != null && !entity.getAbstractAttributeCollection().isEmpty()) {
            Iterator iterator = entity.getAbstractAttributeCollection().iterator();
            while (iterator.hasNext()) {
                Object attribute = iterator.next();
                if (attribute instanceof AttributeInterface) {
                    AttributeInterface deAttribute = (AttributeInterface) attribute;
                    Attribute cab2bAttribute = new Attribute();

                    cab2bAttribute.setId(deAttribute.getId());
                    cab2bAttribute.setName(deAttribute.getName());
                    cab2bAttribute.setDescription(deAttribute.getDescription());
                    cab2bAttribute.setAttributeTypeInformation(deAttribute.getAttributeTypeInformation());
                    cab2bAttribute.setColumnProperties(deAttribute.getColumnProperties());
                    cab2bAttribute.setCreatedDate(deAttribute.getCreatedDate());
                    cab2bAttribute.setEntity(entity);
                    cab2bAttribute.setIsCollection(deAttribute.getIsCollection());
                    cab2bAttribute.setIsIdentified(deAttribute.getIsIdentified());
                    cab2bAttribute.setIsNullable(deAttribute.getIsNullable());
                    cab2bAttribute.setIsPrimaryKey(deAttribute.getIsPrimaryKey());
                    cab2bAttribute.setLastUpdated(deAttribute.getLastUpdated());
                    cab2bAttribute.setRuleCollection(deAttribute.getRuleCollection());
                    cab2bAttribute.setTaggedValueCollection(deAttribute.getTaggedValueCollection());
                    cab2bAttribute.setSemanticPropertyCollection(getSemanticProperty(deAttribute.getSemanticPropertyCollection()));
                    idVsIAttribute.put(cab2bAttribute.getId(),cab2bAttribute);
                    attributeEntityMap.put(cab2bAttribute, entity);
                    
                    for(PermissibleValueInterface value : Utility.getPermissibleValues(cab2bAttribute)) {
                    	PermissibleValue permissibleValue = (PermissibleValue)value;
                    	
                    	StringPermissibleValue stringPermissibleValue = new StringPermissibleValue();
                    	stringPermissibleValue.setValue((String) permissibleValue.getValueAsObject());
                    	stringPermissibleValue.setDescription(permissibleValue.getDescription());
                    	stringPermissibleValue.setId(permissibleValue.getId());
                    	stringPermissibleValue.setSemanticPropertyCollection(getSemanticProperty(permissibleValue.getSemanticPropertyCollection()));
                    	stringPermissibleValue.setSystemIdentifier(permissibleValue.getSystemIdentifier());
                    	permissibleValueToEntityMap.put(stringPermissibleValue,entity);
                    }
                    
                }

                abstractAttributeCollection.add((AbstractAttributeInterface) attribute);
            }
        }
        return abstractAttributeCollection;
    }

    private Collection<SemanticPropertyInterface> getSemanticProperty(
                                                                      Collection<SemanticPropertyInterface> semanticPropertyCollection) {

        Collection<SemanticPropertyInterface> semanticPropertyColl = new HashSet<SemanticPropertyInterface>();

        if (semanticPropertyCollection != null && !semanticPropertyCollection.isEmpty()) {
            Iterator iterator = semanticPropertyCollection.iterator();
            while (iterator.hasNext()) {
                SemanticPropertyInterface deSemanticProperty = (SemanticPropertyInterface) iterator.next();
                SemanticProperty cab2bSemanticProperty = new SemanticProperty();
                cab2bSemanticProperty.setTerm(deSemanticProperty.getTerm());
                cab2bSemanticProperty.setConceptCode(deSemanticProperty.getConceptCode());
                cab2bSemanticProperty.setThesaurasName(deSemanticProperty.getThesaurasName());

                semanticPropertyColl.add(cab2bSemanticProperty);
            }
        }
        return semanticPropertyColl;
    }

    /**
     * Refreshes the entity cache.
     */
    public void refreshCache() {
        init();
    }

    public MatchedClass getEntityOnEntityParameters(Collection entityCollection) {
        MatchedClass matchedClass = new MatchedClass();

        Iterator iterator = entityList.iterator();
        while (iterator.hasNext()) {
            IEntity targetEntity = (IEntity) iterator.next();
            Iterator sourceIterator = entityCollection.iterator();
            while (sourceIterator.hasNext()) {
                IEntity entity = (IEntity) sourceIterator.next();
                if (targetEntity.newEquals(entity)) {
                    matchedClass.getEntityCollection().add((EntityInterface) targetEntity);
                    System.out.println("Entity Class : " + targetEntity.getClass().getName());
                    System.out.println("Enitty Class Name : " + targetEntity.getName());
                }
            }
        }
        return matchedClass;
    }

    /**
     * Returns the Entity objects whose Attribute fields match with the respective not null 
     * fields in the passed Attribute object.
     * @param entity The entity object.
     * @return the Entity objects whose Attribute fields match with the respective not null 
     * fields in the passed Attribute object.
     */
    public MatchedClass getEntityOnAttributeParameters(Collection attributeCollection) {
        return (MatchedClass) attributeEntityMap.get(attributeCollection);
    }
    
    /**
     * Returns the Entity objects whose Permissible value fields match with the respective not null 
     * fields in the passed Permissible value object.
     * @param entity The entity object.
     * @return the Entity objects whose Permissible value fields match with the respective not null 
     * fields in the passed Permissible value object.
     */
    public MatchedClass getEntityOnPermissibleValueParameters(Collection PVCollection)
    {
    	return (MatchedClass) permissibleValueToEntityMap.get(PVCollection);
    }
    
    /**
     * Returns the Entity objects whose source classes fields match with the respective not null 
     * fields in the passed entity object.
     * @param entity The entity object.
     * @return the Entity objects whose source classes fields match with the respective not null 
     * fields in the passed entity object.
     */
    public MatchedClass getCategories(Collection entityCollection){
	    MatchedClass matchedClass=new MatchedClass();
	    CategoryOperations categoryOperations = new CategoryOperations();
	    for(Category category : categories)
	    {    
		    Set<EntityInterface> entities=categoryOperations.getAllSourceClasses(category);
		    
	        for (EntityInterface en : entities) {
	        	IEntity targetEntity = getIEntityById(en.getId());
	            Iterator sourceIterator = entityCollection.iterator();
	            while (sourceIterator.hasNext()) {
	                IEntity entity = (IEntity) sourceIterator.next();
	                if (targetEntity.newEquals(entity)) {
	                	long deEntityID=category.getDeEntityId();
	                	EntityInterface entityInterface=getEntityById(deEntityID);
	                    matchedClass.getEntityCollection().add(entityInterface);	                   
	                }
	            }
	        }
	    }
	    return matchedClass;
	}

    /**
     * Returns the Entity objects whose attributes's source classes fields match with the respective not null 
     * fields in the passed entity object.
     * @param entity The entity object.
     * @return the Entity objects whose attributes's source classes fields match with the respective not null 
     * fields in the passed entity object.
     */
    public MatchedClass getCategoriesAttributes(Collection attributeCollection){
	    MatchedClass matchedClass=new MatchedClass();

	  CategoryOperations categoryOperations = new CategoryOperations();
	    for(Category category : categories)
	    { 
	    	Set<AttributeInterface> attInterface= categoryOperations.getAllSourceAttributes(category);
	    	 for(AttributeInterface attInt : attInterface){
	    		 IAttribute targetAttribute= getIAttributeById(attInt.getId());
	    		 Iterator sourceIterator = attributeCollection.iterator();
	    		 while (sourceIterator.hasNext()) {
		                IAttribute attribute = (IAttribute) sourceIterator.next();
		                if (targetAttribute.newEquals(attribute)) {
		                	long deEntityID=category.getDeEntityId();
		                	EntityInterface entityInterface=getEntityById(deEntityID);
		                    matchedClass.getEntityCollection().add(entityInterface);
		                   
		                }
		            }	    		 
	 	    }	    	
	    }  
	    return matchedClass;
	}


    /**
     * Returns the Entity for given Identifier
     * @param id Id of the entity
     * @return Actual Entity for given id.
     */
    public EntityInterface getEntityById(Long id) {
        EntityInterface entity = idVsEntity.get(id);
        if (entity==null) { 
            throw new RuntimeException("Entity with given id is not present in cache : " + id);
        }
        return entity;
    }

    /**
     * Returns the Association for given Identifier
     * @param id Id of the Association
     * @return Actual Association for given id.
     */
    public AssociationInterface getAssociationById(Long id) {
        AssociationInterface association = idVsAssociation.get(id);
        if (association==null) { 
            throw new RuntimeException("Entity with given id is not present in cache : " + id);
        }
        return association;
    }
    
    /**
     * Returns the Entity for given Identifier
     * @param id Id of the Entity
     * @return Actual Entity for given id.
     */
    IEntity getIEntityById(Long id) {
    	IEntity entity = idVsIEntity.get(id);
        if (entity==null) { 
            throw new RuntimeException("Entity with given id is not present in cache : " + id);
        }
        return entity;
    }
    
    /**
     * Returns the Attribute for given Identifier
     * @param id Id of the Attribute
     * @return Actual Attribute for given id.
     */    
    IAttribute getIAttributeById(Long id) {
    	IAttribute attribute = idVsIAttribute.get(id);
        if (attribute==null) { 
            throw new RuntimeException("Entity with given id is not present in cache : " + id);
        }
        return attribute;
    }
    
    /**
     * Returns the Association for given string. Passed string MUST be of format SourceEntityName + {@link edu.wustl.cab2b.common.util.Constants#CONNECTOR} + TargetRoleName + {@link edu.wustl.cab2b.common.util.Constants#CONNECTOR} + TargetEntityName
     * It can be generated by {@link Utility#generateUniqueId(AssociationInterface)}
     * @param uniqueStringIdentifier unique String Identifier 
     * @return Actual Association for given string identifier.
     */
    public AssociationInterface getAssociationByUniqueStringIdentifier(String uniqueStringIdentifier) {
        AssociationInterface association = originalAssociations.get(uniqueStringIdentifier);
        if (association==null) { 
            throw new RuntimeException("Association with given source entity name and target role name is not present in cache : " + uniqueStringIdentifier);
        }
        return association;
    }
}