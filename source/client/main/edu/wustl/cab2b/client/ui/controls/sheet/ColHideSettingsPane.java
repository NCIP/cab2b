/*
 * ColHideSettingsPane.java
 *
 * Created on October 15, 2007, 1:42 PM
 */

package edu.wustl.cab2b.client.ui.controls.sheet;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.*;
import javax.swing.*;
import javax.swing.event.ListDataListener;
import javax.swing.event.TableModelListener;
import javax.swing.table.*;

/**
 *
 * @author  jasbir_sachdeva
 */
class ColHideSettingsPane extends javax.swing.JPanel implements PropertyChangeListener,
        PropertiesNames {
    
    /** The copy of original Map, passed to this instance.
     *  Required if user wishes to reset form. */
    Map<TableColumn, ColumnExtraState> orgColExtraStateMap =
            new HashMap<TableColumn, ColumnExtraState>();
    
    /** This Visibility map is always inline with the current user changes.
     *  This may be used by underlying JList Model to show user his/her selection.
     *  Bounded Property.
     */
    Map<TableColumn, ColumnExtraState> colExtraStateMap;
    
    ColumnNamesModel namesTblModel;
    ArrayList<TableColumn> colNames = new ArrayList<TableColumn>();
    
    
    /** The default width of the first column.  */
    private int defaultChkColumnWith = 75;
    
    
    
    /** Creates new form ColHideSettingsPane */
    ColHideSettingsPane() {
        initComponents();
        namesTblModel = new ColumnNamesModel();
        tblColSettings.setModel( namesTblModel);
        resetInternalState();
    }
    
    /** Resets the internal staet attibutes of this instance, so
     * that it can be used as fresh. I.e is without any Rows.   */
    private void resetInternalState() {
        colExtraStateMap = new TreeMap<TableColumn, ColumnExtraState>( new TableColumnNamesComparator());
        orgColExtraStateMap.clear();
        namesTblModel.fireTableStructureChanged();
        tblColSettings.getColumnModel().getColumn( 0).setMaxWidth( defaultChkColumnWith);
        colNames.clear();
    }
    
    /** Listens to the Changes in the Column-Extra-State-Vector.
     * Possible change are Addition and Removal of Column.
     */
    public void propertyChange(PropertyChangeEvent evt) {
        if( evt.getPropertyName().compareTo( COLUMNS_REMOVED_ALL) ==0)
            noticeAllColumnsRemoved();
        if( evt.getPropertyName().compareTo( COLUMN_MUTABLE_ADDED) ==0
                || evt.getPropertyName().compareTo( COLUMN_READ_ONLY_ADDED) ==0)
            noticeColumnAdded( (TableColumn)evt.getNewValue());
        else if( evt.getPropertyName().compareTo( COLUMN_MUTABLE_REMOVED) ==0)
            noticeColumnRemoved( (TableColumn)evt.getNewValue());
//        if( evt.getPropertyName().compareTo( PropertiesNames.ALL_MUTABLE_COLUMNS_REMOVED) ==0)
//            noticeColumnRemoved( null);
    }
    
//    /**
//     *  Active Columns definations...
//     */
//    public Map<TableColumn, ColumnExtraState> getColExtraStateMap( ) {
//        return colExtraStateMap;
//    }
    
    
    private void rollbackToCheckPoint() {
//        this.colExtraStateMap = new TreeMap<TableColumn, ColumnExtraState>( new TableColumnNamesComparator());
        colExtraStateMap.clear();
        colExtraStateMap.putAll( orgColExtraStateMap);
        
        prepareTableModel();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        tblColSettings = new javax.swing.JTable();
        jPanel2 = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        butDisplayAll = new javax.swing.JButton();
        butShowEditableColsOnly = new javax.swing.JButton();
        butShowROColsOnly = new javax.swing.JButton();

        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                formComponentShown(evt);
            }
        });
        setLayout(new java.awt.BorderLayout());

        tblColSettings.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane1.setViewportView(tblColSettings);

        add(jScrollPane1, java.awt.BorderLayout.CENTER);

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Hide/Unhide Columns in Data Sheet", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION));

        butDisplayAll.setText("Show All Columns");
        butDisplayAll.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                butDisplayAllActionPerformed(evt);
            }
        });
        jPanel1.add(butDisplayAll);

        butShowEditableColsOnly.setText("Show Editable Columns Only");
        butShowEditableColsOnly.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                butShowEditableColsOnlyActionPerformed(evt);
            }
        });
        jPanel1.add(butShowEditableColsOnly);

        butShowROColsOnly.setText("Show Original Columns Only");
        butShowROColsOnly.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                butShowROColsOnlyActionPerformed(evt);
            }
        });
        jPanel1.add(butShowROColsOnly);

        jPanel2.add(jPanel1);

        add(jPanel2, java.awt.BorderLayout.SOUTH);
    }// </editor-fold>//GEN-END:initComponents
    
    private void butShowROColsOnlyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_butShowROColsOnlyActionPerformed
// TODO add your handling code here:
        setColumnsVisibilty( SHOW_READ_ONLY_COLUMNS_ONLY);
    }//GEN-LAST:event_butShowROColsOnlyActionPerformed
    
    private void butShowEditableColsOnlyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_butShowEditableColsOnlyActionPerformed
// TODO add your handling code here:
        setColumnsVisibilty( SHOW_MUTABLE_COLUMNS_ONLY);
    }//GEN-LAST:event_butShowEditableColsOnlyActionPerformed
    
    private void formComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentShown
// TODO add your handling code here:
        preDisplay();
    }//GEN-LAST:event_formComponentShown
    
    private void butDisplayAllActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_butDisplayAllActionPerformed
// TODO add your handling code here:
        //  revert changes to old saved settings...
        setColumnsVisibilty( SHOW_ALL_COLUMNS);
    }//GEN-LAST:event_butDisplayAllActionPerformed
    
    private void noticeAllColumnsRemoved() {
        resetInternalState();
    }
    
    private void noticeColumnAdded(TableColumn tableColumn) {
        colExtraStateMap.put( tableColumn, (ColumnExtraState)tableColumn.getIdentifier());
        if( isVisible()) {
            //  update chk poiont state...
            orgColExtraStateMap.put( tableColumn, (ColumnExtraState)tableColumn.getIdentifier());
            // refresh display to accomodate new row...
            prepareTableModel();
        }
    }
    
    private void noticeColumnRemoved(TableColumn tableColumn) {
        if( null == tableColumn)
            //   assume all coluns are removed...
            colExtraStateMap.clear();
        else
            colExtraStateMap.remove( tableColumn);
        
        if( isVisible()) {
            //  update chk poiont state...
            orgColExtraStateMap.remove( tableColumn);
            // refresh display to accomodate new row...
            prepareTableModel();
        }
    }
    
    /** Save the state, so that if user like to undo, it is made possible.  */
    private void saveCheckPoint() {
        orgColExtraStateMap.clear();
        orgColExtraStateMap.putAll( colExtraStateMap);
    }
    
    /** Prepares the insternal state in Sync with the available information in colExtraStateMap.
     *      Also intiates the process of taking check point.
     */
    private void preDisplay() {
        saveCheckPoint();
        prepareTableModel();
    }
    
    /** Prepare Table model in sync with the data-view-column's inforamtion avalable in colExtraStateMap Map. */
    private void prepareTableModel() {
        colNames.clear();
        colNames.addAll( this.colExtraStateMap.keySet());
        
        //  prepare table...
        namesTblModel.fireTableStructureChanged();
        tblColSettings.getColumnModel().getColumn( 0).setMaxWidth(
                defaultChkColumnWith);
    }
    
    
    
    
    /**     Set Visiblity as per provided Visbility Criteria.    */
    void setColumnsVisibilty( String visibilityCriteria){
        for( TableColumn affectedTableColumn: colNames) {
            //  Change visibility of all the columns, and notify the regisered listeners...
            ColumnExtraState ces = colExtraStateMap.get( affectedTableColumn);
            if( SHOW_ALL_COLUMNS == visibilityCriteria)
                ces.setColVisible( Boolean.TRUE);
            else if( SHOW_READ_ONLY_COLUMNS_ONLY == visibilityCriteria)
                ces.setColVisible( ces.isReadOnlyColumn());
            else if( SHOW_MUTABLE_COLUMNS_ONLY == visibilityCriteria)
                ces.setColVisible( !ces.isReadOnlyColumn());
            firePropertyChange( PropertiesNames.COLUMN_VISIBLITY_CHANGING, null, affectedTableColumn);
            firePropertyChange( PropertiesNames.COLUMN_VISIBLITY_CHANGED, null, affectedTableColumn);
        }
        //  update UI...
        namesTblModel.fireTableDataChanged();
    }
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton butDisplayAll;
    private javax.swing.JButton butShowEditableColsOnly;
    private javax.swing.JButton butShowROColsOnly;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable tblColSettings;
    // End of variables declaration//GEN-END:variables
    
    
    
    
    
    /** Table Model Impl to accept and keep Columns Visibility Settings.
     *  1st column is check box => to show OR no show
     *  2ns Column => Column name
     */
    class ColumnNamesModel extends AbstractTableModel {
        public int getRowCount() {
            return colNames.size();
        }
        
        public int getColumnCount() {
            return 2;
        }
        
        public String getColumnName(int columnIndex) {
            switch (columnIndex) {
                case 0: return "Visible";
                case 1: return "Column Name";
            }
            return null;
        }
        
        public Class<?> getColumnClass(int columnIndex) {
            switch (columnIndex) {
                case 0: return Boolean.class;
                case 1: return TableColumn.class;
            }
            return Object.class;
        }
        
        public boolean isCellEditable(int rowIndex, int columnIndex) {
            switch (columnIndex) {
                case 0: return true;
                case 1: return false;
            }
            return false;
        }
        
        public Object getValueAt(int rowIndex, int columnIndex) {
            switch (columnIndex) {
                case 0: return colExtraStateMap.get( colNames.get( rowIndex)).isColVisible();
                case 1: return colNames.get( rowIndex).getHeaderValue();
            }
            return null;
        }
        
        public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
            switch (columnIndex) {
                case 0:
                    TableColumn affectedTableColumn = colNames.get( rowIndex);
                    ColumnExtraState ces = colExtraStateMap.get( affectedTableColumn);
                    ces.setColVisible( (Boolean)aValue);
                    firePropertyChange( PropertiesNames.COLUMN_VISIBLITY_CHANGING, null, affectedTableColumn);
                    firePropertyChange( PropertiesNames.COLUMN_VISIBLITY_CHANGED, null, affectedTableColumn);
            }
        }
    }
    
}
