/**
 * <p>Title: EntityCache class>
 * <p>Description:	This class is used to cache the Entity and its Attribute objects.</p>
 * Copyright:    Copyright (c) year
 * Company: Washington University, School of Medicine, St. Louis.
 * @author Gautam Shetty
 * @version 1.00
 */
package edu.wustl.cab2b.server.cache;

import java.io.Serializable;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import edu.common.dynamicextensions.domaininterface.AssociationInterface;
import edu.common.dynamicextensions.domaininterface.AttributeInterface;
import edu.common.dynamicextensions.domaininterface.EntityGroupInterface;
import edu.common.dynamicextensions.domaininterface.EntityInterface;
import edu.common.dynamicextensions.domaininterface.PermissibleValueInterface;
import edu.common.dynamicextensions.entitymanager.EntityManager;
import edu.common.dynamicextensions.entitymanager.EntityManagerInterface;
import edu.common.dynamicextensions.exception.DynamicExtensionsApplicationException;
import edu.common.dynamicextensions.exception.DynamicExtensionsSystemException;
import edu.wustl.cab2b.common.beans.MatchedClass;
import edu.wustl.cab2b.common.entityCache.IEntityCache;
import edu.wustl.cab2b.common.exception.RuntimeException;
import edu.wustl.cab2b.common.util.Constants;
import edu.wustl.cab2b.common.util.Utility;
import edu.wustl.cab2b.server.category.CategoryOperations;
import edu.wustl.cab2b.server.util.InheritanceUtil;
import edu.wustl.common.querysuite.metadata.category.Category;
import edu.wustl.common.util.logger.Logger;

/**
 * This class is used to cache the Entity and its Attribute objects.
 * @author Chandrakant Talele
 * @author gautam_shetty
 * @author Rahul Ner
 */
public class EntityCache implements IEntityCache, Serializable {

    private static final long serialVersionUID = 1234567890L;

    /**
     * Map with KEY as dynamic extension Entity's identifier and Value as Entity object
     */
    protected Map<Long, EntityInterface> idVsEntity = new HashMap<Long, EntityInterface>();

    /**
     * Map with KEY as dynamic extension Association's identifier and Value as Association object
     */
    protected Map<Long, AssociationInterface> idVsAssociation = new HashMap<Long, AssociationInterface>();

    /** This map holds all the original association. Associations which are replicated by cab2b are not present in this map
     * Key : String to identify a parent association uniquely.Generated by {@link InheritanceUtil#generateUniqueId(AssociationInterface)}
     * Value : Original association for given string identifier 
     * */
    protected Map<String, AssociationInterface> originalAssociations = new HashMap<String, AssociationInterface>();

    /**
     * Map with KEY as a permissible value (PV) and VALUE as its Entity. This is needed because there is no back pointer from PV to Entity
     */
    protected Map<PermissibleValueInterface, EntityInterface> permissibleValueVsEntity = new HashMap<PermissibleValueInterface, EntityInterface>();

    /**
     * The EntityCache object. Needed for singleton
     */
    protected static EntityCache entityCache = null;

    /**
     * List of all categories present in the system.
     */
    protected static List<Category> categories;

    /**
     * Private default constructor.
     * To restrict the user from instantiating explicitly.  
     */
    private EntityCache() {
        refreshCache();
    }
    /**
     * Refreshes the entity cache.
     */
    public void refreshCache() {
        init();
    }
    /**
     * @return the singleton instance of the EntityCache class.
     */
    public static synchronized EntityCache getInstance() {
        if (entityCache == null) {
            entityCache = new EntityCache();
        }
        return entityCache;
    }

    /**
     * Initializes the entity cache.
     */
    private void init() throws RuntimeException {
        try {
            Logger.out.info("Initialising cache, this may take few minutes...");
            EntityManagerInterface entityManager = EntityManager.getInstance();
            Collection<EntityGroupInterface> entityGroups = entityManager.getAllEntitiyGroups();
            createCache(entityGroups);
            CategoryOperations catOp = new CategoryOperations();
            categories = catOp.getAllCategories();
            Logger.out.info("Initialising cache DONE");
        } catch (DynamicExtensionsSystemException dynSysExp) {
            throw new RuntimeException(dynSysExp.getMessage(), dynSysExp);
        } catch (DynamicExtensionsApplicationException dynAppExp) {
            throw new RuntimeException(dynAppExp.getMessage(), dynAppExp);
        }
    }

    /**
     * @param entityGroups
     */
    private void createCache(Collection<EntityGroupInterface> entityGroups) {
        for (EntityGroupInterface entityGroup : entityGroups) {
            if (entityGroup.getName().equals(Constants.DATALIST_ENTITY_GROUP_NAME)) {
                continue; //Ignoring entity group of datalist for caching
            }
            for (EntityInterface entity : entityGroup.getEntityCollection()) {
                idVsEntity.put(entity.getId(), entity);
                createAssociationCache(entity);
                createPermissibleValueCache(entity);
            }
        }
    }

    /**
     * @param entity
     */
    private void createAssociationCache(EntityInterface entity) {
        for (AssociationInterface association : entity.getAssociationCollection()) {
            idVsAssociation.put(association.getId(), association);
            if (!InheritanceUtil.isInherited(association)) {
                originalAssociations.put(InheritanceUtil.generateUniqueId(association), association);
            }
        }
    }
    /**
     * @param entity
     */
    private void createPermissibleValueCache(EntityInterface entity) {
        for (AttributeInterface attribute : entity.getAttributeCollection()) {
            for (PermissibleValueInterface value : Utility.getPermissibleValues(attribute)) {
                permissibleValueVsEntity.put(value, entity);
            }
        }
    }

    /**
     * @see edu.wustl.cab2b.common.entityCache.IEntityCache#getEntityOnEntityParameters(java.util.Collection)
     */
    public MatchedClass getEntityOnEntityParameters(Collection<EntityInterface> patternEntityCollection) {
        MatchedClass matchedClass = new MatchedClass();
        for (EntityInterface cachedEntity : idVsEntity.values()) {
            for (EntityInterface patternEntity : patternEntityCollection) {
                if (CompareUtil.compare(cachedEntity, patternEntity)) {
                    matchedClass.addEntity(cachedEntity);
                }
            }
        }
        return matchedClass;
    }

    /**
     * Returns the Entity objects whose Attribute fields match with the respective not null 
     * fields in the passed Attribute object.
     * @param entity The entity object.
     * @return the Entity objects whose Attribute fields match with the respective not null 
     * fields in the passed Attribute object.
     */
    public MatchedClass getEntityOnAttributeParameters(Collection<AttributeInterface> patternAttributeCollection) {
        MatchedClass matchedClass = new MatchedClass();
        for (EntityInterface entity : idVsEntity.values()) {
            for (AttributeInterface cachedAttribute : entity.getAttributeCollection()) {
                for (AttributeInterface patternAttribute : patternAttributeCollection) {
                    if (CompareUtil.compare(cachedAttribute, patternAttribute)) {
                        matchedClass.addAttribute(cachedAttribute);
                        matchedClass.addEntity(cachedAttribute.getEntity());
                    }
                }
            }
        }
        return matchedClass;
    }

    /**
     * Returns the Entity objects whose Permissible value fields match with the respective not null 
     * fields in the passed Permissible value object.
     * @param entity The entity object.
     * @return the Entity objects whose Permissible value fields match with the respective not null 
     * fields in the passed Permissible value object.
     */
    public MatchedClass getEntityOnPermissibleValueParameters(Collection<PermissibleValueInterface> patternPermissibleValueCollection) {
        MatchedClass matchedClass = new MatchedClass();
        for (PermissibleValueInterface cachedPermissibleValue : permissibleValueVsEntity.keySet()) {
            for (PermissibleValueInterface patternPermissibleValue : patternPermissibleValueCollection) {
                if (CompareUtil.compare(cachedPermissibleValue, patternPermissibleValue)) {
                    matchedClass.addEntity(permissibleValueVsEntity.get(cachedPermissibleValue));
                }
            }
        }
        return matchedClass;

    }

    /**
     * Returns the Entity objects whose source classes fields match with the respective not null 
     * fields in the passed entity object.
     * @param entity The entity object.
     * @return the Entity objects whose source classes fields match with the respective not null 
     * fields in the passed entity object.
     */
    public MatchedClass getCategories(Collection<EntityInterface> patternEntityCollection) {
        MatchedClass matchedClass = new MatchedClass();
        CategoryOperations categoryOperations = new CategoryOperations();
        for (Category category : categories) {
            Set<EntityInterface> classesInCategory = categoryOperations.getAllSourceClasses(category);

            for (EntityInterface classInCategory : classesInCategory) {
                for (EntityInterface patternEntity : patternEntityCollection) {
                    if (CompareUtil.compare(classInCategory, patternEntity)) {
                        long deEntityID = category.getDeEntityId();
                        EntityInterface entityInterface = getEntityById(deEntityID);
                        matchedClass.getEntityCollection().add(entityInterface);
                    }
                }
            }
        }
        return matchedClass;
    }

    /**
     * Returns the Entity objects whose attributes's source classes fields match with the respective not null 
     * fields in the passed entity object.
     * @param entity The entity object.
     * @return the Entity objects whose attributes's source classes fields match with the respective not null 
     * fields in the passed entity object.
     */
    public MatchedClass getCategoriesAttributes(Collection<AttributeInterface> patternAttributeCollection) {
        MatchedClass matchedClass = new MatchedClass();

        CategoryOperations categoryOperations = new CategoryOperations();
        for (Category category : categories) {
            Set<AttributeInterface> attributesInCategory = categoryOperations.getAllSourceAttributes(category);
            for (AttributeInterface attributeInCategory : attributesInCategory) {
                for (AttributeInterface patternAttribute : patternAttributeCollection) {
                    if (CompareUtil.compare(attributeInCategory, patternAttribute)) {
                        long deEntityID = category.getDeEntityId();
                        EntityInterface entityInterface = getEntityById(deEntityID);
                        matchedClass.getEntityCollection().add(entityInterface);
                    }
                }
            }
        }
        return matchedClass;
    }

    /**
     * Returns the Entity for given Identifier
     * @param id Id of the entity
     * @return Actual Entity for given id.
     */
    public EntityInterface getEntityById(Long id) {
        EntityInterface entity = idVsEntity.get(id);
        if (entity == null) {
            throw new RuntimeException("Entity with given id is not present in cache : " + id);
        }
        return entity;
    }

    /**
     * Returns the Association for given Identifier
     * @param id Id of the Association
     * @return Actual Association for given id.
     */
    public AssociationInterface getAssociationById(Long id) {
        AssociationInterface association = idVsAssociation.get(id);
        if (association == null) {
            throw new RuntimeException("Entity with given id is not present in cache : " + id);
        }
        return association;
    }

    /**
     * Returns the Association for given string. Passed string MUST be of format SourceEntityName + {@link edu.wustl.cab2b.common.util.Constants#CONNECTOR} + TargetRoleName + {@link edu.wustl.cab2b.common.util.Constants#CONNECTOR} + TargetEntityName
     * It can be generated by {@link Utility#generateUniqueId(AssociationInterface)}
     * @param uniqueStringIdentifier unique String Identifier 
     * @return Actual Association for given string identifier.
     */
    public AssociationInterface getAssociationByUniqueStringIdentifier(String uniqueStringIdentifier) {
        AssociationInterface association = originalAssociations.get(uniqueStringIdentifier);
        if (association == null) {
            throw new RuntimeException(
                    "Association with given source entity name and target role name is not present in cache : "
                            + uniqueStringIdentifier);
        }
        return association;
    }
}